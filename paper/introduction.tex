\section{Introduction} \label{introduction} 

Progress in some branches of
mathematics might be restricted by size of symbolic derivations that humans can
handle. Mathematicians can deal with expressions having dozens of
variables but would struggle to discover useful relations between hundreds or
thousands of variables. We will show how the task of finding equivalent
mathematical expressions can be automated. Our focus is on finding equivalent
mathematical formulas (i.e.~which give an identical numerical result
to the original expression),
but are faster to compute. The definition
of faster can be either (i) the number of operations or (ii) the computational time
for a particular hardware.

We propose a deterministic, grammar-based framework which discovers
relations between multi-variable polynomial expressions. First, we
construct an attribute grammar -- a context-free grammar extended to
contain set of attributes, introduced by Donald Knuth
\cite{knuth1968semantics}. To define the search space we use a set of
context-free grammar rules representing admissible operations. By
representing the cost of every operation as a synthesized attribute
(i.e. computed bottom-up from child node attributes) we can search for
formula with low time complexity. Through a linear combination of
grammar elements, we can find a solution to the desired
expressions. Finally, this computation solution can be further speed
up by use of standard techniques of optimization in compiler
domain. We show the power of the approach by deriving a closed form,
$O(n^3)$ time solution (where $n$ is the number of units) for a Taylor
series approximation to the partition function of an RBM.
% This
%violates the conventional wisdom that accurate computation of the
%partition function requires an exponential number of elements.


%Finally, we can regard the set of generated rules as a algebra with many operators 
%(grammar productions). 
%Goal of algorithm is to find shortest path to the target expression. 
%The brute force algorithm that we consider
%constructs the graph by advancing sequentially from smallest to largest degree.




